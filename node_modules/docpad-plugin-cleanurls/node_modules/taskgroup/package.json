{
  "title": "TaskGroup",
  "name": "taskgroup",
  "version": "3.3.6",
  "description": "Group together synchronous and asynchronous tasks and execute them with support for concurrency, naming, and nesting.",
  "homepage": "https://github.com/bevry/taskgroup",
  "license": {
    "type": "MIT"
  },
  "badges": {
    "travis": true,
    "npm": true,
    "gittip": "bevry",
    "flattr": "344188/balupton-on-Flattr",
    "paypal": "QB8GQPZAH84N6"
  },
  "keywords": [
    "flow",
    "control",
    "async",
    "sync",
    "tasks",
    "batch",
    "concurrency"
  ],
  "author": {
    "name": "2013+ Bevry Pty Ltd",
    "email": "us@bevry.me",
    "url": "http://bevry.me"
  },
  "maintainers": [
    {
      "name": "Benjamin Lupton",
      "email": "b@lupton.cc",
      "url": "https://github.com/balupton"
    }
  ],
  "contributors": [
    {
      "name": "Benjamin Lupton",
      "email": "b@lupton.cc",
      "url": "https://github.com/balupton"
    },
    {
      "name": "sfrdmn",
      "url": "https://github.com/sfrdmn"
    }
  ],
  "bugs": {
    "url": "https://github.com/bevry/taskgroup/issues"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/bevry/taskgroup.git"
  },
  "engines": {
    "node": ">=0.4"
  },
  "dependencies": {
    "ambi": "~2.1.5"
  },
  "devDependencies": {
    "coffee-script": "~1.6.2",
    "joe": "~1.3.0",
    "joe-reporter-console": "~1.2.1",
    "chai": "~1.8.1",
    "projectz": "~0.2.3"
  },
  "directories": {
    "lib": "./out/lib"
  },
  "scripts": {
    "preinstall": "node ./cyclic.js",
    "test": "node ./out/test/taskgroup-test.js"
  },
  "main": "./out/lib/taskgroup.js",
  "readme": "<!-- TITLE/ -->\n\n# TaskGroup\n\n<!-- /TITLE -->\n\n\n<!-- BADGES/ -->\n\n[![Build Status](http://img.shields.io/travis-ci/bevry/taskgroup.png?branch=master)](http://travis-ci.org/bevry/taskgroup \"Check this project's build status on TravisCI\")\n[![NPM version](http://badge.fury.io/js/taskgroup.png)](https://npmjs.org/package/taskgroup \"View this project on NPM\")\n[![Gittip donate button](http://img.shields.io/gittip/bevry.png)](https://www.gittip.com/bevry/ \"Donate weekly to this project using Gittip\")\n[![Flattr donate button](http://img.shields.io/flattr/donate.png?color=yellow)](http://flattr.com/thing/344188/balupton-on-Flattr \"Donate monthly to this project using Flattr\")\n[![PayPayl donate button](http://img.shields.io/paypal/donate.png?color=yellow)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=QB8GQPZAH84N6 \"Donate once-off to this project using Paypal\")\n\n<!-- /BADGES -->\n\n\n<!-- DESCRIPTION/ -->\n\nGroup together synchronous and asynchronous tasks and execute them with support for concurrency, naming, and nesting.\n\n<!-- /DESCRIPTION -->\n\n\n<!-- INSTALL/ -->\n\n## Install\n\n### [Node](http://nodejs.org/), [Browserify](http://browserify.org/)\n- Use: `require('taskgroup')`\n- Install: `npm install --save taskgroup`\n\n### [Ender](http://ender.jit.su/)\n- Use: `require('taskgroup')`\n- Install: `ender add taskgroup`\n\n<!-- /INSTALL -->\n\n\n## Contents\n\n1. [Usage](#usage)\n2. [API](#api)\n3. [Comparisons to other flow libraries](#comparisons)\n4. [Libraries built on top of TaskGroup](#libraries)\n\n\n## Usage\n\nTaskGroup provides two classes, `Task` and `TaskGroup`\n\n\n### Tasks\n\nTasks are used to wrap a function (synchronous or asynchronous, it doesn't matter) inside a task execution flow.\n\nThis is useful for using a consistent interface for executing tasks and doing something on their completion or failure, as well as catching uncaught errors and handling them safely.\n\nWe can define a synchronous task like so:\n\n``` javascript\nvar Task = require('taskgroup').Task\n\n// Create a task for our synchronous function\nvar task = new Task(function(){\n\t// Do something ...\n\treturn \"a synchronous result\";\n\n\t// You can also return an error\n\t// return new Error(\"something went wrong\")\n});\n\n// Add our completion callback for once the task has completed\ntask.once('complete', function(err, result){\n\t// Do something now that the task has completed ...\n\tconsole.log([err, result]);\n\t/* [null, \"a sychronous result\"] */\n});\n\n// Execute the task\ntask.run();\n```\n\nAnd an asynchronous task like so:\n\n``` javascript\nvar Task = require('taskgroup').Task\n\n// Create a task for our synchronous function\nvar task = new Task(function(complete){\n\t// Do something asynchronous\n\tsetTimeout(function(){\n\t\t// the error is the first callback argument, and the results the following arguments\n\t\treturn complete(null, \"an asychronous result\");\n\t\t\n\t\t// So to provide an error instead, you would just pass over the first callback argument\n\t\t// return complete(\"something went wrong\")\n\t}, 5000);  // execute the timeout after 5 seconds\n});\n\n// Add our completion callback for once the task has completed\ntask.once('complete', function(err, result){\n\t// Do something now that the task has completed ...\n\tconsole.log([err, result]);\n\t/* [null, \"an asychronous result\"] */\n});\n\n// Execute the task\ntask.run();\n```\n\n\n### TaskGroup\n\nOften at times, we want to execute multipe things and wait for the completion. TaskGroup makes this easy with the other class, `TaskGroup`.\n\nWe simply create a `TaskGroup` and add out Tasks to it!\n\n``` javascript\nvar TaskGroup = require('taskgroup').TaskGroup\n\n// Create our serial task group\nvar tasks = new TaskGroup();\n\n// Add an asynchronous task to it\ntasks.addTask(function(complete){\n\tsetTimeout(function(){\n\t\treturn complete(null, \"a result\");\n\t}, 5000);  // execute the timeout after 5 seconds\n});\n\n// Add a synchronous task to it\ntasks.addTask(function(){\n\treturn \"a synchronous result\";\n});\n\n// Add our completion callback for once the tasks have completed\ntasks.once('complete', function(err, results){\n\tconsole.log([err, result]);\n\t/* [null, [\n\t\t[null, \"an asychronous result\"],\n\t\t[null, \"a sychronous result\"]\n\t]] */\n});\n\n// Execute the task group\ntasks.run();\n```\n\nNow by default, the TaskGroup will execute serially. This means that each task will execute one by one, waiting for the previous task to complete before moving on to the next task. This can also be considered having a concurrency of `1`. This is called _serial_ execution.\n\nIf we wanted to execute say two tasks at a time we could want a concurrency of `2`, or three tasks at a time, a concurrency of `3` would be set, or unlimited tasks at a time, a concurrency of `0` would be set.\n\nWe can customise the concurrency of the task group by passing it over as a configuration option, either via the TaskGroup constructor or via the `setConfig` method. Let's see what this would look like if we were do a concurrency of `0`. This is called _parallel_ execution.\n\n``` javascript\nvar TaskGroup = require('taskgroup').TaskGroup\n\n// Create our parellel task group\nvar tasks = new TaskGroup({concurrency:0});\n\n// Add an asynchronous task to it\ntasks.addTask(function(complete){\n\tsetTimeout(function(){\n\t\treturn complete(null, \"a result\");\n\t}, 5000);  // execute the timeout after 5 seconds\n});\n\n// Add a synchronous task to it\ntasks.addTask(function(){\n\treturn \"a synchronous result\";\n});\n\n// Add our completion callback for once the tasks have completed\ntasks.once('complete', function(err, results){\n\tconsole.log([err, result]);\n\t/* [null, [\n\t\t[null, \"a sychronous result\"],\n\t\t[null, \"an asychronous result\"]\n\t]] */\n});\n\n// Execute the task group\ntasks.run();\n```\n\nNotice how the groups results are now in a different order. This occured because with parallel execution, we didn't have to wait for the asynchronous fucntion to complete it's 5 second delay before executing and completing the second function (the synchronous one).\n\nYou can mix and match as many functions as you want with TaskGroups.\n\n\n### Nested TaskGroups\n\nYou can also nest TaskGroups inside TaskGroups.\n\nA common use case for this is when you would like a portion of your tasks to execute in parallel, and portion of your tasks to execute in serial.\n\nSuch a use case would look like so:\n\n``` javascript\nvar TaskGroup = require('taskgroup').TaskGroup\n\n// Create our serial task group\nvar tasks = new TaskGroup();\n\n// Add the first serial task\ntasks.addTask(function(){\n\treturn \"first serial task\";\n});\n\n// Add a nested group of tasks that you would like executed in parallel\ntasks.addGroup(function(addGroup, addTask){\n\t// Set this nested group to execute in parallel\n\tthis.setConfig({concurrency: 0});\n\n\t// Add an asynchronous task to the nested group\n\taddTask(function(complete){\n\t\tsetTimeout(function(){\n\t\t\treturn complete(null, \"a result\");\n\t\t}, 5000);  // execute the timeout after 5 seconds\n\t});\n\n\t// Add a synchronous task to the nested group\n\taddTask(function(){\n\t\treturn \"a synchronous result\";\n\t});\n});\n\n// Add the second serial task\ntasks.addTask(function(){\n\treturn \"second serial task\";\n});\n\n// Add our completion callback for once the tasks have completed\ntasks.once('complete', function(err, results){\n\tconsole.log([err, result]);\n\t/* [null, [\n\t\t[null, \"first serial task\"],\n\t\t[null, [\n\t\t\t[null, \"a sychronous result\"],\n\t\t\t[null, \"an asychronous result\"]\n\t\t]],\n\t\t[null, \"second serial task\"]\n\t]] */\n});\n\n// Execute the task group\ntasks.run();\n```\n\n\n### Handling Errors\n\nSafely handling errors is an important thing to do. TaskGroup makes this easy by safely catching any errors that your task my throw, isolating the destruction to the task alone, and providing to the task or taskgroup's completion callback.\n\nWhen an error is detected, the remaining tasks in a TaskGroup will be cleared, and the TaskGroup's completion callback with the error will be fired.\n\n``` javascript\nvar TaskGroup = require('taskgroup').TaskGroup\n\n// Create our serial task group\nvar tasks = new TaskGroup();\n\n// Add a synchronous task to the TaskGroup\ntasks.addTask(function(complete){\n\tsetTimeout(function(){\n\t\treturn complete(new Error(\"the first task failed\"))\n\t}, 5000);  // execute the timeout after 5 second\n});\n\n// Add a synchronous task to the TaskGroup\ntasks.addTask(function(){\n\treturn \"the second task\";\n});\n\n// Add our completion callback for once the tasks have completed\ntasks.once('complete', function(err, results){\n\tconsole.log([err, result]);\n\t/* [Error(\"the first task failed\"), [\n\t\t[Error(\"the first task failed\")]\n\t]] */\n});\n\n// Execute the task group\ntasks.run();\n```\n\nWhich comes in very handling with dealing with asynchronous parallel code:\n\n``` javascript\nvar TaskGroup = require('taskgroup').TaskGroup\n\n// Create our parallel task group\nvar tasks = new TaskGroup({concurrency: 0});\n\n// Add an asynchronous task to the TaskGroup\ntasks.addTask(function(){\n\tsetTimeout(function(){\n\t\treturn complete(\"the first task failed\");\n\t}, 5000);  // execute the timeout after 5 seconds\n});\n\n// Add an asynchronous task to the TaskGroup\ntasks.addTask(function(){\n\tsetTimeout(function(){\n\t\treturn complete(\"the second task failed\");\n\t}, 1000);  // execute the timeout after 1 seconds\n});\n\n// Add our completion callback for once the tasks have completed\ntasks.once('complete', function(err, results){\n\tconsole.log([err, result]);\n\t/* [Error(\"the second task failed\"), [\n\t\t[Error(\"the second task failed\")]\n\t]] */\n});\n\n// Execute the task group\ntasks.run();\n```\n\nNow even though the first task's completion callback still fires, it is sucessfully ignored, as the TaskGroup has exited.\n\n\n### Graduation\n\nNow you know all the essentials to getting started with coding the most amazing (a)synchronous parallel/serial code in your life. Enjoy!\n\n\n\n## API\n\n### Task API\n\n``` javascript\nnew (require('taskgroup')).Task()\n```\n\n- Available methods:\n\t- `constructor(args...)` - create our new task, arguments can be a String for `name`, an Object for `config`, and a Function for `next`\n\t- `setConfig(config)` - set the configuration for the group, returns chain\n\t- `getconfig()` - return the set configuration\n\t- `complete()` - will fire the completion event if we are already complete, useful if you're binding your listeners after run\n\t- `run()` - execute the task\n- Available configuration:\n\t- `name`, no default - allows us to assign a name to the group, useful for debugging\n\t- `method(complete?)`, no default - must be set at some point, it is the function to execute for the task, if it is asynchronous it should use the completion callback provided\n\t- `args`, no default - an array of arguments that you would like to precede the completion callback when executing `fn`\n\t- `next` - alias for  `.once('complete', next)`\n- Available events:\n\t- `run()` - fired just before we execute the task\n\t- `complete(err, args...)` - fired when the task has completed\n\n### TaskGroup API\n\n``` javascript\nnew (require('taskgroup')).TaskGroup()\n```\n\n- Available methods:\n\t- `constructor(name?,fn?)` - create our new group, arguments can be a String for `name`, an Object for `config`, and a Function for `next`\n\t- `setConfig(config)` - set the configuration for the group, returns chain\n\t- `getconfig()` - return the set configuration\n\t- `addTask(args...)`, `addTasks(tasks, args..)`  - create a new task item with the arguments and adds it to the group, returns the new task item(s)\n\t- `addGroup(args...)`, `addGroups(groups, args..)` - create a new group item with the arguments and adds it to the group, returns the new group item(s)\n\t- `addItem(item)`, `addItem(items)`  - adds the items to the group, returns the item(s)\n\t- `getTotals()` - returns counts for the following `{running,remaining,completed,total}`\n\t- `clear()` - remove the remaining items to be executed\n\t- `pause()` - pause the execution of the items\n\t- `stop()` - clear and pause\n\t- `exit(err)` - stop and complete, `err` if specified is sent to the completion event when fired\n\t- `complete()` - will fire the completion event if we are already complete, useful if you're binding your listeners after run\n\t- `run()` - start/resume executing the items, returns chain\n\t- All those of [EventEmitter2](https://github.com/hij1nx/EventEmitter2)\n- Available configuration:\n\t- `name`, no default - allows us to assign a name to the group, useful for debugging\n\t- `method(addGroup, addTask, complete?)`, no default - allows us to use an inline and self-executing style for defining groups, useful for nesting\n\t- `concurrency`, defaults to `1` - how many items shall we allow to be run at the same time, set to `0` to allow unlimited\n\t- `pauseOnError`, defaults to `true` - if an error occurs in one of our items, should we stop executing any remaining items?\n\t\t- setting to `false` will continue with execution with the other items even if an item experiences an error\n\t- `items` - alias for  `.addTasks(items)`\n\t- `groups` - alias for  `.addGroups(groups)`\n\t- `tasks` - alias for  `.addTasks(tasks)`\n\t- `next` - alias for  `.once('complete', next)`\n- Available events:\n\t- `run()` - fired just before we execute the items\n\t- `complete(err, results)` - fired when all our items have completed\n\t- `task.run(task)` - fired just before a task item executes\n\t- `task.complete(task, err, args...)` - fired when a task item has completed\n\t- `group.run(group)` - fired just before a group item executes\n\t- `group.complete(group, err, results)` - fired when a group item has completed\n\t- `item.run(item)` - fired just before an item executes (fired for both sub-tasks and sub-groups)\n\t- `item.complete(item, err, args...)` - fired when an item has completed (fired for both sub-task and sub-groups)\n\n\n\n## Comparisons\n\n### [Async.js](https://github.com/caolan/async)\n\nThe biggest advantage and difference of TaskGroup over async.js is that TaskGroup has one uniform API to rule them all, whereas with async.js I found that I was always having to keep referring to the async manual to try and figure out which is the right call for my use case then somehow wrap my head around the async.js way of doing things (which more often than not I couldn't), whereas with TaskGroup I never have that problem as it is one consistent API for all the different use cases.\n\nLet's take a look at what the most common async.js methods would look like in TaskGroup:\n\n``` javascript\n// ====================================\n// Series\n\n// Async\nasync.series([\n\tfunction(){},\n\tfunction(callback){callback();}\n], next);\n\n// TaskGroup\nnew TaskGroup({\n\ttasks: [\n\t\tfunction(){},\n\t\tfunction(callback){callback();}\n\t],\n\tnext: next\n}).run();\n\n\n// ====================================\n// Parallel\n\n// Async\nasync.parallel([\n\tfunction(){},\n\tfunction(callback){callback();}\n], next);\n\n// TaskGroup\nnew TaskGroup({\n\tconcurrency: 0,\n\ttasks: [\n\t\tfunction(){},\n\t\tfunction(callback){callback();}\n\t],\n\tnext: next\n}).run();\n\n// ====================================\n// Map\n\n// Async\nasync.map(['file1','file2','file3'], fs.stat, next);\n\n// TaskGroup\nnew TaskGroup({\n\tconcurrency: 0,\n\ttasks: ['file1', 'file2', 'file3'].map(function(file){\n\t\treturn function(complete){\n\t\t\tfs.stat(file, complete);\n\t\t}\n\t}),\n\tnext: next\n}).run();\n```\n\nAnother big advantage of TaskGroup over async.js is TaskGroup's ability to add tasks to the group once execution has already started - this is a common use case when creating an application that must perform it's actions serially, so using TaskGroup you can create a serial TaskGroup for the application, run it right away, then add the actions to the group as tasks.\n\nA final big advantage of TaskGroup over async.js is TaskGroup's ability to do nested groups, this allowed us to created the [Joe Testing Framework & Runner](https://github.com/bevry/joe) incredibly easily, and because of this functionality Joe will always know which test (task) is associated to which suite (task group), whereas test runners like mocha have to guess (they add the task to the last group, which may not always be the case! especially with dynamically created tests!).\n\n\n## Libraries\n\nThese are libaries and extensions that are built ontop of TaskGroup's robust API.\n\n- [Joe Test Runner](https://github.com/bevry/joe) — Mocha falls down when you have to create your tests dynamically, because Tests in Joe are Tasks, and Suites are TaskGroups, Joe will always know which tests are for which suite. Works tremendously well, with a modular architecture. Also works in the browser!\n- [Event Emitter Grouped](https://github.com/bevry/event-emitter-grouped) — Execute event listeners as TaskGroups, adding support for asynchronous listeners, parallel execution, and completion callbacks. Great for plugin infrastructures.\n\n\n\n<!-- HISTORY/ -->\n\n## History\n[Discover the change history by heading on over to the `History.md` file.](https://github.com/bevry/taskgroup/blob/master/History.md#files)\n\n<!-- /HISTORY -->\n\n\n<!-- CONTRIBUTE/ -->\n\n## Contribute\n\n[Discover how you can contribute by heading on over to the `Contributing.md` file.](https://github.com/bevry/taskgroup/blob/master/Contributing.md#files)\n\n<!-- /CONTRIBUTE -->\n\n\n<!-- BACKERS/ -->\n\n## Backers\n\n### Maintainers\n\nThese amazing people are maintaining this project:\n\n- Benjamin Lupton <b@lupton.cc> (https://github.com/balupton)\n\n### Sponsors\n\nNo sponsors yet! Will you be the first?\n\n[![Gittip donate button](http://img.shields.io/gittip/bevry.png)](https://www.gittip.com/bevry/ \"Donate weekly to this project using Gittip\")\n[![Flattr donate button](http://img.shields.io/flattr/donate.png?color=yellow)](http://flattr.com/thing/344188/balupton-on-Flattr \"Donate monthly to this project using Flattr\")\n[![PayPayl donate button](http://img.shields.io/paypal/donate.png?color=yellow)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=QB8GQPZAH84N6 \"Donate once-off to this project using Paypal\")\n\n### Contributors\n\nThese amazing people have contributed code to this project:\n\n- Benjamin Lupton <b@lupton.cc> (https://github.com/balupton) - [view contributions](https://github.com/bevry/taskgroup/commits?author=balupton)\n- sfrdmn (https://github.com/sfrdmn) - [view contributions](https://github.com/bevry/taskgroup/commits?author=sfrdmn)\n\n[Become a contributor!](https://github.com/bevry/taskgroup/blob/master/Contributing.md#files)\n\n<!-- /BACKERS -->\n\n\n<!-- LICENSE/ -->\n\n## License\n\nLicensed under the incredibly [permissive](http://en.wikipedia.org/wiki/Permissive_free_software_licence) [MIT license](http://creativecommons.org/licenses/MIT/)\n\nCopyright &copy; 2013+ Bevry Pty Ltd <us@bevry.me> (http://bevry.me)\n<br/>Copyright &copy; 2011-2012 Benjamin Lupton <b@lupton.cc> (http://balupton.com)\n\n<!-- /LICENSE -->\n\n\n",
  "readmeFilename": "README.md",
  "_id": "taskgroup@3.3.6",
  "dist": {
    "shasum": "266ce911aee2ab15a526418a90237a5624b536e7"
  },
  "_from": "taskgroup@~3.3.6",
  "_resolved": "https://registry.npmjs.org/taskgroup/-/taskgroup-3.3.6.tgz"
}
